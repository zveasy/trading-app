"""
Cancel-Replace receiver
───────────────────────
• Listens on tcp://*:5555 for CancelReplaceRequest protobufs
• Places the order the first time the proto_id is seen
• Performs a cancel/replace on subsequent messages with the same proto_id
• Maps proto_id ➜ real IB orderId so that we never send a bogus cancel
"""
import os
import time
import zmq
from dotenv import load_dotenv

# ── Local packages ────────────────────────────────────────────────────────────
from scripts.core import TradingApp, create_contract, create_order
from tests import cr_pb2                    # generated by protoc into tests/

# ── ENV / configuration ───────────────────────────────────────────────────────
load_dotenv()

# Default to paper account if env-var is missing
ACCOUNT_ID = os.getenv("IB_ACCOUNT", "DUH148810")
SYMBOL     = os.getenv("ORDER_SYMBOL", "AAPL")   # hard-coded for demo

# ── ZeroMQ PULL socket ────────────────────────────────────────────────────────
ctx  = zmq.Context()
sock = ctx.socket(zmq.PULL)
sock.bind("tcp://*:5555")
print("Python ZMQ receiver listening on tcp://*:5555 …")

# ── In-memory map:  proto order_id  ➜  IBKR orderId ──────────────────────────
id_map: dict[int, int] = {}


def make_limit_order(action: str, qty: int, price: float):
    """Return a CLEAN limit order (no exotic flags that IB rejects)."""
    ord_               = create_order(action, "LMT", qty, account=ACCOUNT_ID)
    ord_.lmtPrice      = price
    # Strip attributes that sometimes trigger error 10268 / 10269
    for flag in ("eTradeOnly", "firmQuoteOnly", "mifid2Affiliated"):
        if hasattr(ord_, flag):
            setattr(ord_, flag, False)
    return ord_


# ── Main loop ────────────────────────────────────────────────────────────────
while True:
    raw = sock.recv()
    req = cr_pb2.CancelReplaceRequest()

    if not req.ParseFromString(raw):
        print("❌  Invalid protobuf payload")
        continue

    proto_id = req.order_id
    qty      = req.params.new_qty
    price    = req.params.new_price
    print(f"📨  RX proto={proto_id}  qty={qty}  px={price}")

    # Connect to TWS / IB Gateway
    app      = TradingApp(account=ACCOUNT_ID)
    contract = create_contract(SYMBOL)

    if proto_id not in id_map:
        # ➊  FIRST time we see this proto_id → place a NEW order
        ib_id               = app.send_order(contract,
                                             make_limit_order("BUY", qty, price))
        id_map[proto_id]    = ib_id
        print(f"✅  New IB order placed  (proto {proto_id}  ➜  ib {ib_id})")
    else:
        # ➋  Subsequent message → perform cancel/replace
        ib_id               = id_map[proto_id]
        app.update_order(contract,
                         make_limit_order("BUY", qty, price),
                         ib_id)
        print(f"🔄  Cancel/replace sent   (proto {proto_id}  ➜  ib {ib_id})")

    # Let callbacks flush, then disconnect
    time.sleep(1)
    app.disconnect()
