"""
Cancel-Replace receiver
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Listens on tcp://*:5555 for CancelReplaceRequest protobufs
â€¢ Places the order the first time the proto_id is seen
â€¢ Performs a cancel/replace on subsequent messages with the same proto_id
â€¢ Maps proto_id âœ real IB orderId so that we never send a bogus cancel
"""
import os
import time
import zmq
from dotenv import load_dotenv

# â”€â”€ Local packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from scripts.core import TradingApp, create_contract, create_order
from tests import cr_pb2                    # generated by protoc into tests/

# â”€â”€ ENV / configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load_dotenv()

# Default to paper account if env-var is missing
ACCOUNT_ID = os.getenv("IB_ACCOUNT", "DUH148810")
SYMBOL     = os.getenv("ORDER_SYMBOL", "AAPL")   # hard-coded for demo

# â”€â”€ ZeroMQ PULL socket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ctx  = zmq.Context()
sock = ctx.socket(zmq.PULL)
sock.bind("tcp://*:5555")
print("Python ZMQ receiver listening on tcp://*:5555 â€¦")

# â”€â”€ In-memory map:  proto order_id  âœ  IBKR orderId â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id_map: dict[int, int] = {}


def make_limit_order(action: str, qty: int, price: float):
    """Return a CLEAN limit order (no exotic flags that IB rejects)."""
    ord_               = create_order(action, "LMT", qty, account=ACCOUNT_ID)
    ord_.lmtPrice      = price
    # Strip attributes that sometimes trigger error 10268 / 10269
    for flag in ("eTradeOnly", "firmQuoteOnly", "mifid2Affiliated"):
        if hasattr(ord_, flag):
            setattr(ord_, flag, False)
    return ord_


# â”€â”€ Main loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
while True:
    raw = sock.recv()
    req = cr_pb2.CancelReplaceRequest()

    if not req.ParseFromString(raw):
        print("âŒ  Invalid protobuf payload")
        continue

    proto_id = req.order_id
    qty      = req.params.new_qty
    price    = req.params.new_price
    print(f"ğŸ“¨  RX proto={proto_id}  qty={qty}  px={price}")

    # Connect to TWS / IB Gateway
    app      = TradingApp(account=ACCOUNT_ID)
    contract = create_contract(SYMBOL)

    if proto_id not in id_map:
        # âŠ  FIRST time we see this proto_id â†’ place a NEW order
        ib_id               = app.send_order(contract,
                                             make_limit_order("BUY", qty, price))
        id_map[proto_id]    = ib_id
        print(f"âœ…  New IB order placed  (proto {proto_id}  âœ  ib {ib_id})")
    else:
        # â‹  Subsequent message â†’ perform cancel/replace
        ib_id               = id_map[proto_id]
        app.update_order(contract,
                         make_limit_order("BUY", qty, price),
                         ib_id)
        print(f"ğŸ”„  Cancel/replace sent   (proto {proto_id}  âœ  ib {ib_id})")

    # Let callbacks flush, then disconnect
    time.sleep(1)
    app.disconnect()
